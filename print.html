<!DOCTYPE HTML>
<html lang="cn" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graduation Design Report by Azure-stars</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Graduation Design Report by Azure-stars</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Azure-stars/GraduationDesignReport" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>本文档为本科毕设在线记录文档，记录了毕设过程的开发日志和相关资源的链接。欢迎相关的同学交流沟通。</p>
<h2 id="毕设题目"><a class="header" href="#毕设题目">毕设题目</a></h2>
<p>组件化操作系统 ArceOS 的异构实践</p>
<h2 id="联系方式"><a class="header" href="#联系方式">联系方式</a></h2>
<p>若对毕设相关内容有疑问或者感兴趣，可通过 <a href="https://github.com/Azure-stars">我的主页</a> 来联系我。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="研发周报"><a class="header" href="#研发周报">研发周报</a></h1>
<p>本章节为毕设开发周报内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="春季学期第-1-周-2-月-27-日"><a class="header" href="#春季学期第-1-周-2-月-27-日">春季学期第 1 周 (2 月 27 日)</a></h1>
<h2 id="os-比赛测例调整"><a class="header" href="#os-比赛测例调整">OS 比赛测例调整</a></h2>
<ul>
<li>
<p>和龙芯工作人员联系，编译 <a href="https://github.com/LoongsonLab/oscomp-toolchains-for-oskernel/releases/download/loongarch64-linux-musl-cross-gcc-13.2.0/loongarch64-linux-musl-cross.tgz">loongarch64-linux-musl-cross</a> 工具链</p>
</li>
<li>
<p>将工具链用于内核测例编译，并提交 PR 修改内核比赛测例构建 bug：</p>
<ul>
<li><a href="https://github.com/oscomp/testsuits-for-oskernel/pull/19">[fix] use loongarch64 musl gcc to build la image #19</a></li>
<li><a href="https://github.com/oscomp/testsuits-for-oskernel/pull/18">[feat] support basic testcases for loongarch64</a></li>
</ul>
</li>
<li>
<p>更新 ArceOS 和 Starry-Next 在龙芯架构下的构建过程，通过了新的内核测例</p>
<ul>
<li>提供了一个 <a href="https://github.com/oscomp/arceos/blob/main/Dockerfile">Dockerfile</a></li>
<li>重写 <a href="https://github.com/oscomp/starry-next/blob/main/README.md">README</a>，让大家可以更快上手</li>
</ul>
</li>
</ul>
<h2 id="os-比赛环境配置"><a class="header" href="#os-比赛环境配置">OS 比赛环境配置</a></h2>
<ul>
<li>
<p>用 Starry 在 OS 比赛平台上完成了编译运行，并且通过了基本的测例，让 Starry 可以作为一个 Demo 给其他开发者参考进行内核比赛作品的开发。</p>
<ul>
<li>在比赛平台上运行内核的指导详见<a href="https://azure-stars.github.io/Starry-Tutorial-Book/ch01-04.html">文档</a></li>
<li>提交到比赛平台的代码仓库详见<a href="https://gitlab.eduxiji.net/Azure_stars/starry-next/-/tree/pre2025test?ref_type=heads">这里</a></li>
</ul>
</li>
<li>
<p>和训练营与毕设的同学沟通，让他们在这个框架基础上尽快通过更多内核测例</p>
</li>
</ul>
<h2 id="abcoder-项目"><a class="header" href="#abcoder-项目">Abcoder 项目</a></h2>
<ul>
<li>
<p>背景：为 ArceOS 和 Starry 提供更详细的接口文档说明与使用用例说明，让开发者更容易上手</p>
</li>
<li>
<p>期望目标：让开发者不需要了解底层基座内核 ArceOS 的实现，只需要明确接口语义便可以进行内核扩展的开发</p>
</li>
<li>
<p>进度：</p>
<ul>
<li>阅读并了解了 Abcoder 项目的原理</li>
<li>搭建智能体准备开始运行项目</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="春季学期第-2-周-3-月-3-日"><a class="header" href="#春季学期第-2-周-3-月-3-日">春季学期第 2 周 (3 月 3 日)</a></h1>
<h2 id="abcoder-项目-1"><a class="header" href="#abcoder-项目-1">Abcoder 项目</a></h2>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<ul>
<li>使用 Abcoder 对一些复杂项目进行解析，协助改进目前开源的 Abcoder 的功能</li>
<li>了解 Abcoder 的原理和使用方式，并能够指导其他人使用</li>
</ul>
<h3 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h3>
<p>项目组给出了两种方法：Coze 和本地部署 ollama。我试了 Coze 并不是很稳定，而且还需要付钱。他们之前生成的 rcore 解析似乎是内部的模型 API 接口跑的，我直接在 Coze 平台上跑的模型能力和稳定性都不太行。所以我找了台服务器跑了 ollama，使用了 deepseek-coder-v2，并且手动将 context windows 调整到了 4k。速度还算过得去，并开始对 rust 项目进行解析。</p>
<p>这里试的时候遇到了一些问题，简单记录一下：</p>
<ul>
<li>
<p>本来是使用 llama3.2，但是这个模型不太行，所以换成了 deepseek 32b 模型。但是 deepseek32b 模型本身是一个 chat 模型，会进行所谓深度思考，然后输出的解析结果带了很多无用的思考内容，占用了篇幅的同时还让解析时间变慢。于是最后换成了 deepseek coder v2 模型。</p>
</li>
<li>
<p>使用 ollama 跑 deepseek coder v2 的时候发现很多时候解析中断了， 看 log 发现是传入的 prompt 太长了超过了模型的 context windows。ollama 默认开了似乎是 2048 的 max-token，手动将这个模型改为了 4096 的 max-token，应该就没有太大问题了。</p>
<blockquote>
<p>context windows 大小 n 的平方和思考时间成正比，因此开太大也不太好。</p>
</blockquote>
</li>
</ul>
<p>具体的环境配置文档暂时不写，因为这些环境都是我临时找的，给其他人复现的可能性也不高。等之后决定给其他人使用的时候再说。</p>
<p>在这里简单贴一下对于 abcoder 生成结果的解析内容。因为 abcoder 是直接调用了模型的输出然后存储在了一个 json 文件里面，需要提取有效信息并且将其转化为可视文件比如 Markdown。</p>
<pre><code class="language-python"># demo.py
def level_log(log, title):
    print('#' * log + ' ' + title )

import json
# 需要将 abcoder 生成的结果存储在同目录下的 data.json 中
with open('data.json', 'r') as f:
    data = json.load(f)
    for module in data['Modules']:
        if data['Modules'][module]["Dir"] == "":
            continue
        level_log(1, module)
        packages = data['Modules'][module]["Packages"]
        for package in packages:
            level_log(2, package)
            print(packages[package]['compress_data'])
            funcs = packages[package]['Functions']
            level_log(3, "Functions")
            for func in funcs:
                level_log(4, func)
                print(funcs[func]['compress_data'])
            
            level_log(3, "Vars")
            vars = packages[package]['Vars']
            for var in vars:
                # print(var)
                level_log(4, var)
                print(vars[var]['compress_data'])
</code></pre>
<p>运行方式：</p>
<pre><code class="language-sh">$ python3 demo.py &gt; result.md
</code></pre>
<h3 id="结果"><a class="header" href="#结果">结果</a></h3>
<ul>
<li>
<p>先解析了一个自己写的简单 rust 项目：<a href="https://github.com/Azure-stars/dependencies-patch">dependencies-patch</a>。得到的结果详见 <a href="./dependencies.html">dependencies-parse</a></p>
</li>
<li>
<p>然后最近会尝试开始解析 ArceOS 等内核，今天试了一下似乎有点慢。</p>
</li>
</ul>
<h2 id="os-比赛支持"><a class="header" href="#os-比赛支持">OS 比赛支持</a></h2>
<h3 id="内核测例多架构支持"><a class="header" href="#内核测例多架构支持">内核测例多架构支持</a></h3>
<p>将 2025 初赛测例进行修改，编译为 x86_64/riscv64/aarch64/loongarch64 四个架构的镜像。</p>
<ul>
<li>测例仓库上<a href="https://github.com/oscomp/testsuits-for-oskernel/tree/2025_multiarch">2025_multiarch</a>目前可以支持同时编译生成 x86_64/riscv64/aarch64/loongarch64 四个架构的 Musl 和 glibc 测例。</li>
<li>starry-next 仓库已经通过的 riscv64 和 loongarch64 测例也可以通过 x86_64 和 aarch64 的版本。</li>
<li>预编译好的镜像发布在 <a href="https://github.com/Azure-stars/testsuits-for-oskernel/releases/tag/v0.1">2025年初赛SD卡镜像</a></li>
</ul>
<p>并且我提供了一个新的 docker 镜像。该镜像下可以支持编译比赛测例，并且运行 starry-next 内核，输出这些测例的运行信息。Docker 镜像对应的构建仓库详见 https://github.com/Azure-stars/os-contest-2024-image，可以为比赛平台评测机所用镜像和即将到来的 Github CICD 工作作参考。</p>
<h3 id="内核测例-bug-修复"><a class="header" href="#内核测例-bug-修复">内核测例 Bug 修复</a></h3>
<p><a href="https://github.com/oscomp/testsuits-for-oskernel/tree/pre-2025">pre-2025</a>分支为本年度赛事使用的初赛测例所在分支。经过和几位同学的测试，发现测例内存在一些 Bug，并通过 PR 或者直接 commit 的形式进行了修复。共提交了 4 次修复。</p>
<h3 id="初赛测例分析"><a class="header" href="#初赛测例分析">初赛测例分析</a></h3>
<p>在编译出 x86_64 的镜像之后，便可以在 Linux 主机上进行系统调用分析。通过解析 strace 生成的 log 可以快速得到测例在 Linux 下所需的 syscall 和相关的行为。</p>
<p>以 <code>musl-busybox</code> 测例为例子，在 <code>sdcard/musl</code> 目录执行如下指令：</p>
<pre><code class="language-sh">strace -f -e trace='!read,write,readv,writev,lseek,dup' -o strace_musl_busybox.log ./busybox sh ./busybox_testcode.sh
</code></pre>
<p>即可得到 busybox 调用的 log。</p>
<blockquote>
<p><code>-e trace='!read,write,readv,writev,lseek,dup</code> 是为了避免 LOG 中输出过内容导致文件过大。因为 IOZONE 等测例会执行非常多次相关的 syscall 进行 benchmark 测试，因此需要过滤掉这类 syscall。</p>
</blockquote>
<p>我们简单对这类 LOG 进行分析：</p>
<pre><code class="language-python"># Description: Extract syscall list from strace log file
import argparse
argparser = argparse.ArgumentParser()
argparser.add_argument('-s', '--strace_log', type=str, help='strace log file')
args = argparser.parse_args()

STRACE_LOG = args.strace_log
SYSCALL_LIST = []

with open(STRACE_LOG + '.log', 'r') as f:
    lines = f.readlines()
    for line in lines:
        if '(' not in line:
            continue
        # If using strace -f to trace, the first field of each line is the pid, so we need to remove it
        if line[0].isdigit():
            line = line.split(' ', 1)[1]
        syscall = line.split('(')[0]
        # Remove useless information
        if syscall.find('&lt;') != -1 or syscall.find('+') != -1:
            continue
        if syscall not in SYSCALL_LIST:
            SYSCALL_LIST.append(syscall)

with open(STRACE_LOG + '_syscall_list.txt', 'w') as f:
    for syscall in SYSCALL_LIST:
        f.write(syscall + '\n')
</code></pre>
<p>即可得到支持 busybox 测例所需要的 syscall 列表 <a href="https://github.com/Azure-stars/GraduationDesignReport/blob/main/parse_syscall/strace_musl_busybox_syscall_list.txt">syscall_list</a>。</p>
<p>对所有的测例进行统计，可以得到 musl 测例下所需要的 <a href="https://github.com/Azure-stars/GraduationDesignReport/blob/main/parse_syscall/strace_musl_testcases_syscall_list.txt">syscall list</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>本附录对文档中提到的资源进行整理和说明。</p>
<ul>
<li><a href="appendix-01.html">相关资源说明</a></li>
<li><a href="dependencies.html">Abcoder 解析结果示例</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录-相关资源"><a class="header" href="#附录-相关资源">附录: 相关资源</a></h1>
<p>本附录对文档中提到的资源进行整理和说明。</p>
<h2 id="活动说明"><a class="header" href="#活动说明">活动说明</a></h2>
<ul>
<li><a href="https://os.educg.net/#/">全国大学生计算机系统能力大赛</a>：即文档中提到的 OS 比赛，其中的操作系统内核实现赛道包含了一系列内核测例，可以验证内核自身的功能和性能。</li>
</ul>
<h2 id="代码仓库"><a class="header" href="#代码仓库">代码仓库</a></h2>
<h3 id="原始代码仓库"><a class="header" href="#原始代码仓库">原始代码仓库</a></h3>
<ul>
<li>
<p><a href="https://github.com/arceos-org/arceos">arceos-org/arceos</a>：ArceOS 是由清华大学贾越凯博士开发的组件化操作系统。它本身是一个 Unikernel 架构的操作系统，可以支持宏内核、hypervisor 等架构的扩展，是本毕设的基础前置工作。</p>
</li>
<li>
<p><a href="https://github.com/Starry-OS/Starry-Old">Starry-OS/Starry-Old</a>：Starry 是基于 ArceOS 开发的宏内核，参与全国大学生操作系统大赛并通过了决赛阶段的绝大部分测例。</p>
</li>
<li>
<p><a href="https://github.com/arceos-org/starry-next">arceos-org/starry-next</a>：Starry-Next 是 Starry 的下一代版本，它将对 Starry 进行重构，以较小的代码量实现更加完善的宏内核功能，验证组件化开发的优势和可行性，是本毕设的主要目标。该仓库是上游稳定仓库，更新较慢。</p>
</li>
</ul>
<h3 id="衍生代码仓库"><a class="header" href="#衍生代码仓库">衍生代码仓库</a></h3>
<ul>
<li>
<p><a href="https://github.com/oscomp/arceos">oscomp/arceos</a>：ArceOS 适配到 OS 比赛的衍生仓库。该仓库为 ArceOS 添加了各类 OS 比赛所需的支持，包括 loongarch64 指令集架构支持、新的功能接口等，并会在将来逐渐合入到上游仓库中，也是本毕设的主要工作仓库。</p>
</li>
<li>
<p><a href="https://github.com/oscomp/starry-next">oscomp/starry-next</a>：Starry-Next 适配到 OS 比赛的衍生仓库。该仓库为 Starry-Next 添加了各类 OS 比赛所需的支持，包括 loongarch64 指令集架构支持、新的功能接口等，并会在将来逐渐合入到上游仓库中，也是本毕设的主要工作仓库。</p>
</li>
</ul>
<h2 id="相关说明文档"><a class="header" href="#相关说明文档">相关说明文档</a></h2>
<p>Starry 的相关说明文档详见 <a href="https://azure-stars.github.io/Starry-Tutorial-Book/">Starry-Tutorial-Book</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-patch"><a class="header" href="#dependencies-patch">dependencies-patch</a></h1>
<h2 id="dependencies-patchgit_patch"><a class="header" href="#dependencies-patchgit_patch">dependencies-patch::git_patch</a></h2>
<p>此包位于dependencies-patch::git_patch，主要功能是处理Git补丁的相关信息，特别是Git仓库名称、包重命名信息、补丁版本以及补丁目标的具体信息。它包含一个名为<code>GitPatch</code>的结构体，该结构体包含了以下字段：</p>
<ul>
<li><code>git</code>: String, 表示Git仓库名称。</li>
<li><code>package</code>: Option<String>, 可能包含包的重命名信息。</li>
<li><code>version</code>: Option<String>, 补丁版本信息。</li>
<li><code>info</code>: GitInfo, 补丁目标信息。</li>
</ul>
<p>关键类型：
- <code>GitPatch</code>：一个结构体，包含了Git仓库名称、包重命名信息、补丁版本以及补丁目标的具体信息。
- <code>GitInfo</code>：一个枚举类型，用于表示Git仓库的信息。它包含以下几种变体：
- <code>None</code>: 没有特定的信息。
- <code>Commit(String)</code>: 提交哈希值，表示一个具体的提交。
- <code>Tag(String)</code>: 标签名称，表示一个具体的标签。
- <code>Branch(String)</code>: 分支名称，表示一个具体的分支。
- <code>String</code>：字符串类型，用于表示文本数据。
- <code>Option</code>：枚举类型，用于表示可能存在的值或可能缺失的值。它有两个变体：Some(T)和None。</p>
<p>此包通过提供结构化的Git补丁信息处理机制，确保了在复杂的Git操作中能够准确地管理和使用补丁相关的元数据，为应用中的版本控制和补丁管理提供了便利。</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<h4 id="check_git_patch_format"><a class="header" href="#check_git_patch_format">check_git_patch_format</a></h4>
<p>CheckGitPatchFormat函数用于检查给定的Git补丁是否符合正确的格式，即仓库名称应为<code>owner/repo</code>的形式。</p>
<p>入参：</p>
<ul>
<li>patch: 一个指向GitPatch类型的指针。</li>
</ul>
<p>出参：</p>
<ul>
<li>Ok((owner, repo)): 如果补丁的仓库名称格式正确，返回仓库的所有者和仓库名。</li>
<li>Err(mes): 如果补丁的仓库名称格式不正确，返回错误信息。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>将补丁的仓库名称按<code>/</code>分割成一个字符串向量。</li>
<li>检查向量的长度是否为2。</li>
<li>如果是2，则将第一个元素作为所有者，第二个元素作为仓库名，返回Ok((owner, repo))。</li>
<li>如果长度不为2，则根据补丁的仓库名称生成错误信息并返回Err(mes)。</li>
</ol>
<h4 id="gitpatchnew"><a class="header" href="#gitpatchnew">GitPatch::new</a></h4>
<p>Create a new git patch with specific information including the repository name, optional package and version names, and detailed GitInfo.</p>
<h4 id="do_git_patch"><a class="header" href="#do_git_patch">do_git_patch</a></h4>
<h3 id=""><a class="header" href="#"></a></h3>
<h3 id="vars"><a class="header" href="#vars">Vars</a></h3>
<h4 id="git_table"><a class="header" href="#git_table">git_table</a></h4>
<p><code>git_table</code> 是一个变量，它从 <code>patch_toml_table</code> 中获取一个可变的 TOML 表。</p>
<h4 id="real_package_name"><a class="header" href="#real_package_name">real_package_name</a></h4>
<p><code>real_package_name</code> 是一个变量，用于在给定包名不存在时，回退到默认的包名。它在代码中通过匹配操作来决定其值：</p>
<ul>
<li>如果存在一个名为 <code>patch.package</code> 的可选包名（Some(name)），则使用该名称。</li>
<li>否则，使用预定义的全局变量 <code>package_name</code>。</li>
</ul>
<p>这个变量主要用于处理包名的选择逻辑，确保在任何情况下都能获取到一个有效的包名。</p>
<h4 id="mut-toml_table-package_index"><a class="header" href="#mut-toml_table-package_index">(mut toml_table, package_index)</a></h4>
<p><code>tolm_table</code> 是一个可变的全局变量，主要用于处理TOML格式的配置表。它与 <code>gen_patch_table</code> 函数和 <code>package_index</code> 相关联。</p>
<p><code>toml_table</code> 的主要功能是从指定的路径读取并解析一个TOML文件，获取名为 "patch" 的表，并将其转换为可变表。如果操作成功，则返回该表；否则，程序将终止执行。</p>
<h4 id="patch_toml_table"><a class="header" href="#patch_toml_table">patch_toml_table</a></h4>
<p><code>patch_toml_table</code>是一个变量，用于获取并操作一个TOML表中的“patch”部分。该变量主要功能是提供对特定TOML表格的修改能力。</p>
<h4 id="patch_git"><a class="header" href="#patch_git">patch_git</a></h4>
<p><code>patch_git</code>是一个字符串变量，用于存储从给定的命名参数构造的Git仓库URL。</p>
<p>它主要关联的主要函数是<code>format!</code>，用于格式化字符串。</p>
<h4 id="mut-file"><a class="header" href="#mut-file">mut file</a></h4>
<p><code>file</code> 是一个变量，主要功能是作为文件句柄，用于对指定路径下的 <code>Cargo.toml</code> 文件进行追加操作。该变量关联的主要函数或类型是 <code>OpenOptions</code> 结构体，它用于配置文件系统的打开选项。具体来说：</p>
<ul>
<li><code>OpenOptions::new()</code> 创建一个新的 <code>OpenOptions</code> 实例，用于设置各种打开选项。</li>
<li><code>.append(true)</code> 设置追加模式为 true，表示在写入数据时将内容添加到文件末尾。</li>
<li><code>.open(format!("{}/Cargo.toml", cargo_path))</code> 根据给定的路径格式化字符串并尝试以追加模式打开文件。如果路径不存在或无法打开，程序将抛出 <code>panic</code>。</li>
<li><code>.unwrap()</code> 用于处理可能的错误情况，确保程序在遇到错误时不会崩溃。</li>
</ul>
<h4 id="mut-patch_table"><a class="header" href="#mut-patch_table">mut patch_table</a></h4>
<p><code>patch_table</code>是一个可变变量，初始化为一个新的<code>Table</code>实例。它主要用于存储补丁信息或配置表数据。</p>
<h4 id="names"><a class="header" href="#names">names</a></h4>
<p><code>names</code>是一个字符串数组变量，用于存储路径分隔后的名称。它主要在Git相关的操作中使用。</p>
<h2 id="dependencies-patchcargo_parse"><a class="header" href="#dependencies-patchcargo_parse">dependencies-patch::cargo_parse</a></h2>
<p>此包位于dependencies-patch::cargo_parse，专注于解析Cargo Package中的依赖关系，特别是处理source字段为Git仓库或注册表的依赖项。主要功能如下：</p>
<p>关键函数：
- CargoPackage.parse_dependency: 该函数用于将Cargo Package中的source字段解析为Dependency类型。其主要功能包括：
1. 检查source是否以“git+”开头，如果是，则提取出Git仓库URL。
2. 如果找到问号（?），则截取到问号前的部分作为Git地址；否则，直接使用整个字符串作为Git地址。
3. 如果source以“registry+”开头，则返回一个默认的注册表信息Dependency::Registry("crates-io".to_string())。
4. 如果source既不以“git+”也不以“registry+”开头，则调用panic!函数终止程序并报告错误。</p>
<p>此包通过提供对依赖项来源的有效解析，确保了项目在处理Git仓库或注册表时的准确性和可靠性，避免了潜在的错误和不确定性。</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<h4 id="cargopackageparse_dependency"><a class="header" href="#cargopackageparse_dependency">CargoPackage.parse_dependency</a></h4>
<p>解析依赖函数用于将CargoPackage中的source字段解析为Dependency类型。该函数主要功能如下：</p>
<ol>
<li>检查source是否以“git+”开头，如果是，则提取出Git仓库URL。</li>
<li>如果找到问号（?），则截取到问号前的部分作为Git地址；否则，直接使用整个字符串作为Git地址。</li>
<li>如果source以“registry+”开头，则返回一个默认的注册表信息Dependency::Registry("crates-io".to_string())。</li>
<li>如果source既不以“git+”也不以“registry+”开头，则调用panic!函数终止程序并报告错误。</li>
</ol>
<h4 id="pick_package"><a class="header" href="#pick_package">pick_package</a></h4>
<p>pick_package函数用于从指定的Cargo路径中选择特定的包。主要功能包括：检查Cargo.toml和Cargo.lock文件是否存在，如果不存在则生成新的Cargo.lock文件；解析Cargo.lock文件以查找指定名称的包并返回结果。</p>
<p>入参：</p>
<ul>
<li>cargo_path: 一个指向String类型的指针，表示Cargo项目的路径。</li>
<li>package_name: 一个指向String类型的指针，表示要选择的包的名称。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>检查指定的Cargo路径下是否存在Cargo.toml文件，如果不存在则返回错误信息。</li>
<li>获取Cargo.lock文件的路径，并检查其是否存在，如果不存在则记录警告日志并生成新的Cargo.lock文件。</li>
<li>读取并解析Cargo.lock文件，查找指定名称的包，如果找不到则返回错误信息。</li>
<li>返回找到的包或错误信息。</li>
</ol>
<h3 id="vars-1"><a class="header" href="#vars-1">Vars</a></h3>
<h4 id="output"><a class="header" href="#output">output</a></h4>
<p><code>output</code>是一个变量，主要功能是用于执行系统命令。它关联的主要函数是<code>std::process::Command::new("cargo").arg("generate-lockfile").current_dir(cargo_path).spawn().expect(...)</code>，用于生成锁文件。这个命令接口包含几个方法，如<code>.arg()</code>用于添加参数，<code>.current_dir()</code>用于设置当前目录，以及<code>.spawn()</code>和<code>.wait()</code>用于执行命令并等待其完成。</p>
<h4 id="cargo_toml_path"><a class="header" href="#cargo_toml_path">cargo_toml_path</a></h4>
<p><code>cargo_toml_path</code>是一个字符串变量，用于表示Cargo项目的TOML文件路径。该路径是通过将<code>cargo_path</code>与字符串<code>"/Cargo.toml"</code>连接生成的。</p>
<h4 id="git_url"><a class="header" href="#git_url">git_url</a></h4>
<p><code>git_url</code> 是一个字符串变量，它的主要功能是从一个给定的源字符串中提取特定的部分。具体来说，它通过以下步骤从源字符串中提取URL：</p>
<ol>
<li>将源字符串按 <code>#</code> 分割成多个子字符串，形成一个向量。</li>
<li>获取向量的第一个元素（即第一个子字符串）。</li>
<li>如果该子字符串存在，则将其转换为字符串类型并进行下一步操作。</li>
<li>从字符串中去掉前四个字符。</li>
</ol>
<p><code>git_url</code> 变量并未关联主要函数或类型，它仅用于简化对源字符串特定部分的提取和处理。</p>
<h4 id="cargo_lock"><a class="header" href="#cargo_lock">cargo_lock</a></h4>
<p>cargo_lock是一个<code>CargoLock</code>类型的变量，主要功能是管理和定义依赖包的版本信息。它包含一个字段<code>package</code>，类型为<code>Vec&lt;CargoPackage&gt;</code>，用于存储多个依赖包的信息。</p>
<h4 id="cargo_lock_path"><a class="header" href="#cargo_lock_path">cargo_lock_path</a></h4>
<p><code>cargo_lock_path</code>是一个字符串变量，用于存储Cargo包管理工具的锁定文件路径。它的值是通过格式化操作生成的，具体格式为在<code>cargo_path</code>后面加上"/Cargo.lock"。该变量没有关联的主要函数或类型。</p>
<h2 id="dependencies-patcharg_parse"><a class="header" href="#dependencies-patcharg_parse">dependencies-patch::arg_parse</a></h2>
<p>此包位于<code>dependencies-patch::arg_parse</code>，专注于为命令行工具提供修补Cargo依赖项的功能。它定义了一个名为<code>Args</code>的类型，这是一个结构体，用于配置如何修补Cargo依赖项。关键字段包括<code>cargo_path</code>、<code>package_name</code>、<code>patch_type</code>、<code>real_package_name</code>、<code>package_version</code>、<code>git_repo</code>、<code>commit</code>、<code>branch</code>、<code>tag</code>和<code>patch_path</code>，每个都有特定的用途。</p>
<p>关键类型：
- Args: 一个结构体，用于配置修补Cargo依赖项的参数，包括项目路径、包名、修补类型以及具体的Git仓库信息或本地路径。</p>
<p>此包提供了一个简单的命令行工具接口，使用户能够指定项目路径和包名，并选择修补类型（如Git仓库、注册表或本地路径），从而实现依赖项的灵活修补。</p>
<h3 id="functions-2"><a class="header" href="#functions-2">Functions</a></h3>
<h4 id="parse_args"><a class="header" href="#parse_args">parse_args</a></h4>
<p><code>parse_args</code> 函数的主要功能是解析命令行参数。如果参数无效（例如，类型设置为 <code>git</code> 但 Git 仓库未提供），则返回 <code>None</code>。函数的主要步骤如下：</p>
<ol>
<li>使用 <code>Args::parse()</code> 解析命令行参数到 <code>Args</code> 结构体中。</li>
<li>根据 <code>patch_type</code> 字段的值进行不同的验证和处理：
<ul>
<li>如果 <code>patch_type</code> 是 <code>git</code>，则检查 <code>git_repo</code> 是否为空，如果不为空，进一步检查 <code>commit</code>、<code>branch</code> 和 <code>tag</code> 是否冲突。</li>
<li>如果 <code>patch_type</code> 是 <code>path</code>，则检查 <code>patch_path</code> 是否为空。</li>
<li>如果 <code>patch_type</code> 是 <code>registry</code>，则检查 <code>package_version</code> 是否为空。</li>
<li>如果 <code>patch_type</code> 不支持，记录错误日志并返回 <code>None</code>。</li>
</ul>
</li>
<li>设置默认的 <code>cargo_path</code> 值（如果不存在的话）。</li>
<li>返回解析后的参数 <code>Some(args)</code>。</li>
</ol>
<p>该函数依赖以下类型：</p>
<ul>
<li><code>Args</code>: 命令行工具的参数结构体，包含多种字段用于配置修补 Carg</li>
</ul>
<h3 id="vars-2"><a class="header" href="#vars-2">Vars</a></h3>
<h4 id="judge_array"><a class="header" href="#judge_array">judge_array</a></h4>
<p><code>judge_array</code> 是一个数组变量，包含三个元素：<code>args.commit</code>、<code>args.branch</code> 和 <code>args.tag</code> 的引用。这个数组主要用于存储和传递相关信息，具体用途可能与代码中的分支判断、版本控制或其他逻辑处理有关。</p>
<h4 id="mut-args"><a class="header" href="#mut-args">mut args</a></h4>
<p><code>args</code>是一个可变变量，属于<code>Args</code>类型，主要功能是配置如何修补Cargo依赖项。<code>Args</code>类型是一个命令行工具的参数结构体，包含多个字段：<code>cargo_path</code>、<code>package_name</code>、<code>patch_type</code>、<code>real_package_name</code>、<code>package_version</code>、<code>git_repo</code>、<code>commit</code>、<code>branch</code>、<code>tag</code>和<code>patch_path</code>。该变量与命令行工具的参数解析功能相关联。</p>
<h2 id="dependencies-patchlogger"><a class="header" href="#dependencies-patchlogger">dependencies-patch::logger</a></h2>
<p>这个包位于 dependencies-patch::logger，主要功能是提供日志记录服务。它不包含任何公开的函数、类型或变量。由于缺乏具体的功能描述和代码示例，无法详细总结其基本功能和用途。</p>
<h3 id="functions-3"><a class="header" href="#functions-3">Functions</a></h3>
<h4 id="error_log"><a class="header" href="#error_log">error_log</a></h4>
<p>error_log宏的主要功能是将错误日志记录到指定的位置。</p>
<p>该函数的每个参数的意义：</p>
<ul>
<li>无显式参数，因为这是一个宏（macro）而不是函数。</li>
</ul>
<h4 id="patch_error"><a class="header" href="#patch_error">patch_error</a></h4>
<p>该函数的主要功能是格式化错误信息并打印输出。它接受一个<code>std::fmt::Arguments</code>类型的参数，表示要格式化的字符串参数。函数的执行流程如下：</p>
<ol>
<li>使用<code>format!</code>宏将输入的<code>args</code>格式化为一个新的字符串<code>error</code>。</li>
<li>调用<code>cprintln!</code>宏，该宏用于解析颜色标签并打印输出带颜色的文本。</li>
<li><code>cprintln!</code>宏接受一个包含颜色和文本的TokenStream作为参数，这里使用了自定义的颜色标签来突出显示错误信息。</li>
</ol>
<h4 id="warn_log"><a class="header" href="#warn_log">warn_log</a></h4>
<p>该宏定义用于将警告日志记录到日志系统中。
入参：</p>
<ul>
<li>$($arg:tt)*: 可变数量的参数，表示要格式化的日志内容。
出参：无直接的出参，但调用了crate::logger::patch_warn函数进行实际的日志记录。</li>
</ul>
<h4 id="patch_warn"><a class="header" href="#patch_warn">patch_warn</a></h4>
<p>patch_warn函数用于格式化并打印警告信息。
入参：</p>
<ul>
<li>args: std::fmt::Arguments类型的参数，包含要打印的格式化字符串和参数。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>使用format宏将args转换为String类型，赋值给变量warn。</li>
<li>调用cprintln宏，打印格式化的警告信息。</li>
</ol>
<h4 id="patch_info"><a class="header" href="#patch_info">patch_info</a></h4>
<p>该函数名为patch_info，用于格式化并打印信息。
入参：</p>
<ul>
<li>args: std::fmt::Arguments类型，表示要格式化的参数集合。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>使用format!宏将args参数进行格式化，生成一个字符串info。</li>
<li>调用cprintln!宏，将格式化后的信息打印出来，前缀为<green><bold>[INFO]</bold></green>，后跟格式化的info内容。</li>
</ol>
<h4 id="info_log"><a class="header" href="#info_log">info_log</a></h4>
<p>该宏定义了一个名为<code>info_log</code>的日志记录宏，用于在代码中插入信息性日志。</p>
<p>主要功能和用途：</p>
<ul>
<li><code>info_log!</code>宏提供了一种方便的方式来格式化并记录信息性日志消息。它将传入的参数进行格式化处理后，调用<code>crate::logger::patch_info</code>函数进行日志记录。</li>
</ul>
<p>参数：</p>
<ul>
<li>无直接参数（输入参数通过宏展开传递给<code>format_args!</code>）</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li><code>info_log!</code>宏接收任意数量和类型的输入参数。</li>
<li>这些参数会被传递给<code>format_args!</code>函数进行格式化处理。</li>
<li>格式化后的日志消息被传递给<code>crate::logger::patch_info</code>函数进行记录。</li>
</ol>
<h3 id="vars-3"><a class="header" href="#vars-3">Vars</a></h3>
<h4 id="info"><a class="header" href="#info">info</a></h4>
<p><code>info</code>是一个字符串变量，主要功能是将格式化的字符串和参数组合在一起。这个变量关联的主要函数或类型是<code>format!</code>宏，用于将字符串与参数进行格式化拼接。</p>
<h4 id="warn"><a class="header" href="#warn">warn</a></h4>
<p><code>warn</code>是一个格式化字符串变量，主要功能是使用给定的参数进行格式化输出。</p>
<p>该变量关联的主要函数或类型没有具体提及。</p>
<h4 id="error"><a class="header" href="#error">error</a></h4>
<p><code>error</code>是一个格式化的错误信息字符串变量，使用Rust编程语言中的<code>format!</code>宏来生成。</p>
<h2 id="dependencies-patchpath_patch"><a class="header" href="#dependencies-patchpath_patch">dependencies-patch::path_patch</a></h2>
<p>此包位于dependencies-patch::path_patch，专注于为包路径提供补丁信息的管理工具。关键函数：</p>
<ul>
<li>PathPatch::new(package string, path string) -&gt; PathPatch: 使用提供的<code>package</code>和<code>path</code>参数创建一个新的PathPatch实例。该实例包含了初始化的<code>package</code>和<code>path</code>字段，用于表示可能被重命名的包名和补丁的目标路径。</li>
</ul>
<p>关键类型：</p>
<ul>
<li>PathPatch: 是一个结构体，包含两个字段：</li>
<li>package：一个可选的字符串类型，表示可能在Cargo.toml文件中被重命名的实际包名。</li>
<li>path：一个字符串类型，表示补丁的目标路径。该类型主要功能是提供对包路径的详细描述，以便在构建系统或版本控制系统中进行管理和调整。</li>
</ul>
<h3 id="functions-4"><a class="header" href="#functions-4">Functions</a></h3>
<h4 id="do_path_patch"><a class="header" href="#do_path_patch">do_path_patch</a></h4>
<p>do_path_patch函数的主要功能是将特定包的信息插入到Git仓库的Cargo.toml文件中。</p>
<p>入参：</p>
<ul>
<li>cargo_path: 一个指向String类型的指针，表示Cargo项目的路径。</li>
<li>package_name: 一个指向String类型的指针，表示要选择的包的名称。</li>
<li>patch: 一个PathPatch结构体，包含补丁信息。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>根据patch中的package字段或默认使用package_name来确定实际的包名（real_package_name）。</li>
<li>调用gen_patch_table函数生成补丁表，如果生成失败则直接返回。</li>
<li>从补丁表中获取与指定包相关的索引（package_index）。</li>
<li>初始化一个空的补丁表（patch_table）并插入path信息。</li>
<li>将补丁表插入到Cargo.toml文件中，以追加模式打开文件并在文件末尾写入补丁内容。</li>
</ol>
<p>主要依赖函数：</p>
<ul>
<li>gen_patch_table: 生成补丁表，用于在Cargo.toml文件中插入或更新补丁信息。</li>
</ul>
<h4 id="pathpatchnew"><a class="header" href="#pathpatchnew">PathPatch::new</a></h4>
<p>PathPatch结构体用于表示对包路径的补丁信息，主要功能包括：</p>
<ul>
<li>提供一个可选的字符串类型字段<code>package</code>，表示可能在Cargo.toml文件中被重命名的实际包名。</li>
<li>提供一个字符串类型字段<code>path</code>，表示补丁的目标路径。</li>
</ul>
<p>该结构体的主要执行流程如下：</p>
<ol>
<li>使用两个参数<code>package</code>和<code>path</code>来初始化一个新的PathPatch实例。</li>
<li><code>package</code>参数是可选的，可以为空或包含一个字符串值。</li>
<li><code>path</code>参数是一个必需的字符串值，表示补丁的目标路径。</li>
<li>创建并返回一个新的PathPatch实例，该实例包含了初始化的<code>package</code>和<code>path</code>字段。</li>
</ol>
<h3 id="vars-4"><a class="header" href="#vars-4">Vars</a></h3>
<h4 id="real_package_name-1"><a class="header" href="#real_package_name-1">real_package_name</a></h4>
<p><code>real_package_name</code> 是一个变量，用于在给定包名和补丁包名之间进行匹配。如果存在补丁包名（即非空），则使用补丁包名；否则，使用原始包名。这个变量主要功能是提供一个统一的包名字符串，以确保在使用包时不会出现歧义或错误。</p>
<h4 id="index_table"><a class="header" href="#index_table">index_table</a></h4>
<p><code>index_table</code> 是一个变量，主要用于获取和操作一个 TOML 表。它在代码中被用来获取并修改一个包索引的表格配置。</p>
<h4 id="patch_toml_table-1"><a class="header" href="#patch_toml_table-1">patch_toml_table</a></h4>
<p><code>patch_toml_table</code> 是一个变量，主要功能是获取并操作一个名为 "patch" 的 TOML 表。这个表是通过调用 <code>toml_table.get_mut("patch").unwrap().as_table_mut().unwrap()</code> 语句获得的。它关联的主要函数是 <code>GetPackageIndexTable</code>，该函数用于进一步操作和获取与包索引相关的表。</p>
<h4 id="mut-file-1"><a class="header" href="#mut-file-1">mut file</a></h4>
<p><code>file</code> 是一个可变变量，关联的主要函数或类型是 <code>OpenOptions</code>。<code>OpenOptions</code> 是一个结构体，主要用于配置文件系统的打开选项。它包含以下字段：</p>
<ul>
<li>Create：一个布尔值，指示是否在文件不存在时创建新文件。</li>
<li>Truncate：一个布尔值，指示是否在打开文件时截断文件到零长度。</li>
<li>Mode：一个整数，用于设置文件的权限模式（Unix）或访问控制（Windows）。</li>
</ul>
<p><code>file</code> 变量的主要功能是打开一个文件以便追加内容。</p>
<h4 id="mut-patch_table-1"><a class="header" href="#mut-patch_table-1">mut patch_table</a></h4>
<p><code>patch_table</code>是一个可变变量，初始化为一个新的<code>Table</code>实例。它主要用于存储补丁信息或其他相关数据。</p>
<h4 id="mut-toml_table-package_index-1"><a class="header" href="#mut-toml_table-package_index-1">(mut toml_table, package_index)</a></h4>
<p>let (mut toml_table, package_index) 是一个包含两个元素的元组，其中第一个元素是可变引用（mut）的 toml_table，第二个元素是 package_index。这个元组主要用于在 gen_patch_table 函数返回结果存在时，获取 patch 表的 mut 引用。</p>
<p>关联的主要函数是 <code>gen_patch_table</code> 和 <code>get_mut("patch")</code>，它们分别用于生成补丁表和获取 "patch" 表的可变引用。</p>
<h2 id="dependencies-patchindex_patch"><a class="header" href="#dependencies-patchindex_patch">dependencies-patch::index_patch</a></h2>
<p>此包位于dependencies-patch::index_patch，专注于提供一个索引补丁的创建和管理工具。它包括一个主要功能是提供一个构造函数<code>new</code>，用于初始化IndexPatch实例。IndexPatch类型是一个结构体，包含两个字段：</p>
<ul>
<li>package: Option<String> - 包的真实名称可能在其Cargo.toml文件中被重命名。</li>
<li>version: String - 补丁的版本号。
主要功能是提供一个构造函数<code>new</code>，用于初始化IndexPatch实例。此类型还与标准库中的字符串类型(String)和泛型枚举类型(Option)相关联。</li>
</ul>
<h3 id="functions-5"><a class="header" href="#functions-5">Functions</a></h3>
<h4 id="do_index_patch"><a class="header" href="#do_index_patch">do_index_patch</a></h4>
<p>do_index_patch函数的主要功能是将特定包的信息补丁到Git仓库中。</p>
<p>入参：</p>
<ul>
<li>cargo_path: 一个指向String类型的指针，表示Cargo项目的路径。</li>
<li>package_name: 一个指向String类型的指针，表示要选择的包的名称。</li>
<li>patch: 一个指向IndexPatch类型的指针，包含补丁信息。</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>根据patch中的package字段或直接使用package_name来确定实际的包名（real_package_name）。</li>
<li>调用gen_patch_table函数生成补丁表（toml_table）和包索引（package_index）。</li>
<li>如果gen_patch_table返回的结果存在，则获取其补丁信息并插入到Cargo.toml文件中。</li>
<li>打开Cargo.toml文件并在末尾追加补丁表的内容。</li>
</ol>
<h4 id="indexpatchnew"><a class="header" href="#indexpatchnew">IndexPatch::new</a></h4>
<p>IndexPatch类型用于创建一个新的索引补丁，包含包的真实名称和版本号。
IndexPatch结构体有两个字段：</p>
<ul>
<li>package: Option<String> - 包的真实名称可能在其Cargo.toml文件中被重命名。</li>
<li>version: String - 补丁的版本号。
主要功能是提供一个构造函数<code>new</code>，用于初始化IndexPatch实例。</li>
</ul>
<h3 id="vars-5"><a class="header" href="#vars-5">Vars</a></h3>
<h4 id="mut-toml_table-package_index-2"><a class="header" href="#mut-toml_table-package_index-2">(mut toml_table, package_index)</a></h4>
<p><code>toml_table</code> 是一个可变的全局变量，主要用于处理TOML格式的配置文件。它与函数 <code>gen_patch_table</code> 和 <code>SetBufferSizeLimit</code> 相关联。</p>
<h4 id="mut-file-2"><a class="header" href="#mut-file-2">mut file</a></h4>
<p><code>file</code> 是一个变量，主要功能是作为一个文件句柄，用于追加内容到指定的 Cargo.toml 文件中。关联的主要函数或类型是 <code>OpenOptions</code> 结构体，它用于配置文件系统的打开选项。具体字段包括：</p>
<ul>
<li><code>Create</code>: 一个布尔值，指示是否在文件不存在时创建新文件。</li>
<li><code>Truncate</code>: 一个布尔值，指示是否在打开文件时截断文件到零长度。</li>
<li><code>Mode</code>: 一个整数，用于设置文件的权限模式（Unix）或访问控制（Windows）。</li>
</ul>
<h4 id="index_table-1"><a class="header" href="#index_table-1">index_table</a></h4>
<p><code>index_table</code>是一个变量，用于获取并操作一个TOML表。它关联的主要函数或类型是<code>patch_toml_table</code>和<code>package_index</code>。</p>
<h4 id="real_package_name-2"><a class="header" href="#real_package_name-2">real_package_name</a></h4>
<p><code>real_package_name</code> 是一个变量，用于匹配并赋值包名。它在 <code>match</code> 语句中根据 <code>&amp;patch.package</code> 的值来决定其具体值：</p>
<ul>
<li>如果 <code>patch.package</code> 存在（即 <code>Some(name)</code>），则将其值赋给 <code>real_package_name</code>。</li>
<li>如果 <code>patch.package</code> 不存在（即 <code>None</code>），则使用预定义的 <code>package_name</code>。</li>
</ul>
<p>该变量主要用于获取或设置包名，具体取决于 <code>patch.package</code> 是否存在。</p>
<h4 id="patch_toml_table-2"><a class="header" href="#patch_toml_table-2">patch_toml_table</a></h4>
<p><code>patch_toml_table</code> 是一个变量，主要用于获取并操作一个名为 "patch" 的 TOML 表。它关联的主要函数或类型是 Rust 语言中的 <code>get_mut</code>, <code>as_table_mut</code>, 和 <code>unwrap</code> 方法。</p>
<h4 id="mut-patch_table-2"><a class="header" href="#mut-patch_table-2">mut patch_table</a></h4>
<p><code>patch_table</code>是一个可变变量，初始化时为一个新的<code>Table</code>实例。这个变量主要用于存储补丁表信息，但没有关联的主要函数或类型。</p>
<h2 id="dependencies-patchpatch"><a class="header" href="#dependencies-patchpatch">dependencies-patch::patch</a></h2>
<p>此包位于dependencies-patch::patch，主要功能不明确，可能是一个用于依赖关系管理的工具。目前没有公开的函数、类型或变量描述，因此无法提供具体的总结内容。建议提供更多的上下文信息以便更好地理解其用途和功能。</p>
<h3 id="functions-6"><a class="header" href="#functions-6">Functions</a></h3>
<h4 id="gen_patch_table"><a class="header" href="#gen_patch_table">gen_patch_table</a></h4>
<p>gen_patch_table函数的主要功能是根据给定的Cargo项目路径、包名称和实际包名生成补丁表。它用于在Cargo.toml文件中插入或更新与指定包相关的补丁信息。
入参：</p>
<ul>
<li>cargo_path: 一个指向String类型的指针，表示Cargo项目的路径。</li>
<li>package_name: 一个指向String类型的指针，表示要选择的包的名称。</li>
<li>real_package_name: 一个指向String类型的指针，表示实际的包名。
出参：</li>
<li>Some((patch_table, package_index)): 一个元组，包含补丁表和包索引。
主要执行流程：</li>
</ul>
<ol>
<li>使用pick_package函数根据实际包名获取包信息。</li>
<li>解析包依赖关系，判断是否存在补丁。</li>
<li>如果补丁已存在或包是路径依赖，则返回None。</li>
<li>初始化一个Cargo.toml表并插入补丁字段。</li>
<li>根据包依赖类型设置补丁内容，返回补丁表和包索引。</li>
</ol>
<h4 id="patch"><a class="header" href="#patch">patch</a></h4>
<p>patch函数的主要功能是根据args参数中的patch_type字段，对指定的包路径进行补丁操作。具体来说，它会根据patch_type的不同值，执行不同的补丁操作：</p>
<ul>
<li>如果patch_type为"git"，则它会创建一个GitPatch实例，并调用do_git_patch函数进行处理。</li>
<li>如果patch_type为"registry"，则它会创建一个IndexPatch实例，并调用do_index_patch函数进行处理。</li>
<li>对于其他情况（即patch_type不匹配上述两种情况），则会创建一个PathPatch实例，并调用do_path_patch函数进行处理。</li>
</ul>
<p>具体执行流程如下：</p>
<ol>
<li>从args参数中提取cargo_path字段，该字段表示Cargo项目的路径。</li>
<li>根据patch_type的值，执行相应的补丁操作：
<ul>
<li>如果patch_type为"git"，则进一步检查commit、tag和branch字段的值（如果有），并创建一个GitInfo实例来存储这些信息。然后使用这些信息和args中的其他参数来创建一个GitPatch实例，最后调用do_git_patch函数进行处理。</li>
<li>如果patch_type为"registry"，则直接使用args中的参数来创建一个IndexPatch实例，并调用do_index_patch函数进行处理。</li>
<li>对于其他情况，则根据args中的参数创建一个PathPatch实例，并调用do_path_patch函数进行处理。</li>
</ul>
</li>
<li>根据不同的补丁类型执行相应的补丁操作。</li>
</ol>
<h4 id="check_patch_exist"><a class="header" href="#check_patch_exist">check_patch_exist</a></h4>
<p>Check whether the patch exists for the specific package
入参：</p>
<ul>
<li>cargo_path: &amp;String - 包含项目路径的字符串引用</li>
<li>package_name: &amp;String - 包名称的字符串引用</li>
<li>package_dependency: &amp;Dependency - 依赖类型的引用
出参：</li>
<li>bool - 布尔值，表示补丁是否存在</li>
</ul>
<p>主要执行流程：</p>
<ol>
<li>构建Cargo.toml文件路径。</li>
<li>读取并解析Cargo.toml文件内容。</li>
<li>检查补丁表是否包含指定包的名称或Git地址。</li>
<li>根据依赖类型进一步检查补丁表中是否存在相关补丁。</li>
</ol>
<h3 id="vars-6"><a class="header" href="#vars-6">Vars</a></h3>
<h4 id="cargo_toml_path-1"><a class="header" href="#cargo_toml_path-1">cargo_toml_path</a></h4>
<p><code>cargo_toml_path</code>是一个字符串变量，用于表示Cargo.toml文件的路径。它通过将<code>cargo_path</code>和字符串<code>"/Cargo.toml"</code>拼接而成。</p>
<h4 id="patch_table"><a class="header" href="#patch_table">patch_table</a></h4>
<p><code>patch_table</code>是一个变量，用于获取并操作Cargo.toml文件中的“patch”部分。它是一个表（table），允许对其进行修改。</p>
<h4 id="git_patch"><a class="header" href="#git_patch">git_patch</a></h4>
<p><code>git_patch</code> 是一个结构体变量，主要功能是存储 Git 仓库的相关信息。它包含以下字段：</p>
<ul>
<li>git: String, 表示 Git 仓库名称。</li>
<li>package: Option<String>, 可能包含包的重命名信息。</li>
<li>version: Option<String>, 补丁版本信息。</li>
<li>info: GitInfo, 补丁目标信息。</li>
</ul>
<p>关联的主要类型是 <code>GitInfo</code>，这是一个枚举类型，用于表示 Git 仓库的信息，包含以下几种变体：</p>
<ul>
<li>None: 没有特定的信息。</li>
<li>Commit(String): 提交哈希值，表示一个具体的提交。</li>
<li>Tag(String): 标签名称，表示一个具体的标签。</li>
<li>Branch(String): 分支名称，表示一个具体的分支。</li>
</ul>
<p>此外，还涉及到的类型包括 <code>String</code> 和 <code>Option</code>，其中 <code>String</code> 用于表示文本数据，而 <code>Option</code> 是一个枚举类型，用于表示可能存在的值或可能缺失的值。</p>
<h4 id="path_patch"><a class="header" href="#path_patch">path_patch</a></h4>
<p><code>path_patch</code> 是一个变量，属于 <code>PathPatch</code> 类型的实例。这个类型是一个结构体，用于表示对包路径的补丁信息。它包含两个字段：</p>
<ul>
<li><code>package</code>: 一个可选的字符串类型，表示可能在 Cargo.toml 文件中被重命名的实际包名。</li>
<li><code>path</code>: 一个字符串类型，表示补丁的目标路径。</li>
</ul>
<p>主要功能和用途是提供对包路径的详细描述，以便在构建系统或版本控制系统中进行管理和调整。</p>
<h4 id="registry_table"><a class="header" href="#registry_table">registry_table</a></h4>
<p><code>registry_table</code>是一个变量，用于获取一个名为 "crates-io" 的表（可能是从某个配置或数据结构中）。这个表是从 <code>patch_table</code> 中获取的，确保了这个操作不会失败（通过 <code>unwrap()</code> 方法）。</p>
<h4 id="mut-git_info"><a class="header" href="#mut-git_info">mut git_info</a></h4>
<p><code>git_info</code> 是一个可变的变量，初始值为 <code>GitInfo::None</code>。它是一个枚举类型，用于表示 Git 仓库的信息。主要包含以下几种变体：</p>
<ul>
<li><code>None</code>: 没有特定的信息。</li>
<li><code>Commit(String)</code>: 提交哈希值，表示一个具体的提交。</li>
<li><code>Tag(String)</code>: 标签名称，表示一个具体的标签。</li>
<li><code>Branch(String)</code>: 分支名称，表示一个具体的分支。</li>
</ul>
<p>该类型主要用于在 Rust 代码中表示 Git 仓库的不同信息状态，以便进行版本控制和标识。</p>
<h4 id="cargo_toml"><a class="header" href="#cargo_toml">cargo_toml</a></h4>
<p>cargo_toml是一个表变量，用于解析和存储Cargo.toml文件的内容。它通过调用toml::from_str函数从字符串中解析Cargo.toml文件内容并赋值给cargo_toml变量。</p>
<h4 id="cargo_path"><a class="header" href="#cargo_path">cargo_path</a></h4>
<p><code>cargo_path</code>是一个变量，它从命令行参数中获取路径并解包。主要功能是提供一个文件或目录的路径，供后续程序使用。</p>
<h4 id="index_patch"><a class="header" href="#index_patch">index_patch</a></h4>
<p><code>index_patch</code>是一个<code>IndexPatch</code>类型的变量，主要功能是存储包的真实名称和版本号。它包含两个字段：<code>package</code>和<code>version</code>。</p>
<ul>
<li><code>package</code>是一个可选的字符串类型（<code>Option&lt;String&gt;</code>），表示包的实际名称，可能在其Cargo.toml文件中被重命名。</li>
<li><code>version</code>是一个标准库中的字符串类型，表示补丁的版本号。</li>
</ul>
<h4 id="mut-cargo_toml"><a class="header" href="#mut-cargo_toml">mut cargo_toml</a></h4>
<p>cargo_toml 是一个可变的全局变量，类型为 Table。它主要用于管理 Cargo.toml 文件的配置信息。与它相关的函数或方法包括获取和修改配置项。</p>
<h4 id="package"><a class="header" href="#package">package</a></h4>
<p>let package是一个变量，用于在匹配pick_package函数的返回结果时存储包信息。如果pick_package函数调用成功（即返回Ok），则将返回的包赋值给package；如果失败（返回Err），则会记录错误日志并返回None。</p>
<h4 id="package_dependency"><a class="header" href="#package_dependency">package_dependency</a></h4>
<p><code>package_dependency</code>是一个变量，它通过调用<code>package.parse_dependency()</code>方法来解析包依赖。主要功能是存储解析后的包依赖信息，没有关联的主要函数或类型。</p>
<h2 id="dependencies-patch-1"><a class="header" href="#dependencies-patch-1">dependencies-patch</a></h2>
<p>该包位于dependencies-patch，主要功能不明确，没有公开的函数、类型或变量描述。</p>
<h3 id="functions-7"><a class="header" href="#functions-7">Functions</a></h3>
<h4 id="main"><a class="header" href="#main">main</a></h4>
<p>main函数的主要功能是解析命令行参数并将这些参数传递给patch函数进行进一步处理。如果解析命令行参数成功，则继续调用patch函数对指定的包路径进行补丁操作；否则，直接返回。</p>
<p>入参：</p>
<ul>
<li>无
出参：</li>
<li>无</li>
</ul>
<p>主要执行流程如下：</p>
<ol>
<li>使用<code>parse_args</code>函数解析命令行参数，并将其存储在变量<code>args</code>中。如果解析失败，则程序直接返回。</li>
<li>调用<code>patch</code>函数，根据<code>args</code>中的<code>patch_type</code>字段，对指定的包路径进行相应的补丁操作：
<ul>
<li>如果<code>patch_type</code>为"git"，则创建一个GitPatch实例并调用do_git_patch函数进行处理。</li>
<li>如果<code>patch_type</code>为"registry"，则创建一个IndexPatch实例并调用do_index_patch函数进行处理。</li>
<li>对于其他情况（即<code>patch_type</code>不匹配上述两种情况），则创建一个PathPatch实例并调用do_path_patch函数进行处理。</li>
</ul>
</li>
</ol>
<h3 id="vars-7"><a class="header" href="#vars-7">Vars</a></h3>
<h4 id="args"><a class="header" href="#args">args</a></h4>
<p><code>args</code>是一个变量，用于存储解析命令行参数的结果。如果没有通过<code>parse_args()</code>函数成功解析到参数，程序将直接退出（return）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
